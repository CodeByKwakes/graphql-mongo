var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/* eslint-disable no-param-reassign, no-use-before-define */

import { GraphQLInt } from 'graphql';
import { Resolver, TypeComposer, omit } from 'graphql-compose';

import { prepareConnectionType } from './types/connectionType';
import { prepareSortType } from './types/sortInputType';
import CursorType from './types/cursorType';
import { cursorToData, dataToCursor } from './cursor';

export function prepareConnectionResolver(typeComposer, opts) {
  if (!(typeComposer instanceof TypeComposer)) {
    throw new Error('First arg for prepareConnectionResolver() should be instance of TypeComposer');
  }

  if (!opts.countResolverName) {
    throw new Error('TypeComposer(' + typeComposer.getTypeName() + ') provided to composeWithConnection ' + 'should have option `opts.countResolverName`.');
  }
  var countResolver = typeComposer.getResolver(opts.countResolverName);
  if (!countResolver) {
    throw new Error('TypeComposer(' + typeComposer.getTypeName() + ') provided to composeWithConnection ' + ('should have resolver with name \'' + opts.countResolverName + '\' ') + 'due opts.countResolverName.');
  }
  var countResolve = countResolver.getResolve();

  if (!opts.findResolverName) {
    throw new Error('TypeComposer(' + typeComposer.getTypeName() + ') provided to composeWithConnection ' + 'should have option `opts.findResolverName`.');
  }
  var findManyResolver = typeComposer.getResolver(opts.findResolverName);
  if (!findManyResolver) {
    throw new Error('TypeComposer(' + typeComposer.getTypeName() + ') provided to composeWithConnection ' + ('should have resolver with name \'' + opts.findResolverName + '\' ') + 'due opts.countResolverName.');
  }
  var findManyResolve = findManyResolver.getResolve();

  var additionalArgs = {};
  if (findManyResolver.hasArg('filter')) {
    // $FlowFixMe
    additionalArgs.filter = findManyResolver.getArg('filter');
  }

  var sortEnumType = prepareSortType(typeComposer, opts);

  return new Resolver({
    outputType: prepareConnectionType(typeComposer),
    name: 'connection',
    kind: 'query',
    args: _extends({
      first: {
        type: GraphQLInt,
        description: 'Forward pagination argument for returning at most first edges'
      },
      after: {
        type: CursorType,
        description: 'Forward pagination argument for returning at most first edges'
      },
      last: {
        type: GraphQLInt,
        description: 'Backward pagination argument for returning at most last edges'
      },
      before: {
        type: CursorType,
        description: 'Backward pagination argument for returning at most last edges'
      }
    }, additionalArgs, {
      sort: {
        type: sortEnumType,
        defaultValue: sortEnumType.getValues()[0].value,
        description: 'Sort argument for data ordering'
      }
    }),
    resolve: async function resolve(resolveParams) {
      var countPromise = void 0;
      var _resolveParams$projec = resolveParams.projection;
      var projection = _resolveParams$projec === undefined ? {} : _resolveParams$projec;
      var args = resolveParams.args;
      var rawQuery = resolveParams.rawQuery;

      var findManyParams = Object.assign({}, resolveParams);

      var first = parseInt(args.first, 10) || 0;
      if (first < 0) {
        throw new Error('Argument `first` should be non-negative number.');
      }
      var last = parseInt(args.last, 10) || 0;
      if (last < 0) {
        throw new Error('Argument `last` should be non-negative number.');
      }

      var countParams = _extends({}, findManyParams, {
        rawQuery: rawQuery,
        args: {
          filter: Object.assign({}, _extends({}, findManyParams.args.filter))
        }
      });

      if (projection.count) {
        countPromise = countResolve(countParams);
      } else if (!first && last) {
        countPromise = countResolve(countParams);
      } else {
        countPromise = Promise.resolve(0);
      }

      if (projection && projection.edges) {
        // combine top level projection (maybe somebody add additional fields via resolveParams.projection)
        // and edges.node (record needed fields)
        findManyParams.projection = Object.assign({}, projection, projection.edges.node || {});
      } else {
        findManyParams.projection = Object.assign({}, projection);
      }

      if (!first && last) {
        first = await countPromise;
        first = parseInt(first, 10) || 0;
      }

      var limit = last || first || 20;
      var skip = last > 0 ? first - last : 0;

      var prepareCursorData = void 0;
      var sortConfig = findSortConfig(opts.sort, args.sort);
      if (sortConfig) {
        prepareRawQuery(resolveParams, sortConfig);
        findManyParams.rawQuery = resolveParams.rawQuery;
        sortConfig.cursorFields.forEach(function (fieldName) {
          findManyParams.projection[fieldName] = true;
        });

        prepareCursorData = function prepareCursorData(record) {
          var result = {};
          sortConfig.cursorFields.forEach(function (fieldName) {
            result[fieldName] = record[fieldName];
          });
          return result;
        };
      } else {
        (function () {
          var _prepareLimitSkipFall = prepareLimitSkipFallback(resolveParams, limit, skip);

          var _prepareLimitSkipFall2 = _slicedToArray(_prepareLimitSkipFall, 2);

          limit = _prepareLimitSkipFall2[0];
          skip = _prepareLimitSkipFall2[1];


          var skipIdx = -1;
          prepareCursorData = function prepareCursorData() {
            skipIdx += 1;
            return skip + skipIdx;
          };
        })();
      }

      findManyParams.args.limit = limit + 1; // +1 document, to check next page presence
      if (skip > 0) {
        findManyParams.args.skip = skip;
      }

      // pass findMany ResolveParams to top resolver
      resolveParams.findManyResolveParams = findManyParams;
      resolveParams.countResolveParams = countParams;

      return Promise.all([findManyResolve(findManyParams), countPromise]).then(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2);

        var recordList = _ref2[0];
        var count = _ref2[1];

        var edges = [];
        // transform record to object { cursor, node }
        recordList.forEach(function (record) {
          edges.push({
            cursor: dataToCursor(prepareCursorData(record)),
            node: record
          });
        });
        return [edges, count];
      }).then(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2);

        var edges = _ref4[0];
        var count = _ref4[1];

        var result = emptyConnection();
        result.edges = edges.length > limit ? edges.slice(0, limit) : edges;

        result.pageInfo = preparePageInfo(edges, args, limit, skip);
        result.count = count;

        return result;
      });
    }
  });
}

export function preparePageInfo(edges, args, limit, skip) {
  var pageInfo = {
    startCursor: '',
    endCursor: '',
    hasPreviousPage: false,
    hasNextPage: false
  };

  var hasExtraRecords = edges.length > limit;

  // pageInfo may be extended, so set data gradually
  if (edges.length > 0 && limit > 0) {
    pageInfo.startCursor = edges[0].cursor;
    if (hasExtraRecords) {
      pageInfo.endCursor = edges[limit - 1].cursor;
    } else {
      pageInfo.endCursor = edges[edges.length - 1].cursor;
    }
    pageInfo.hasPreviousPage = !!args.last && skip > 0;
    pageInfo.hasNextPage = !!args.first && hasExtraRecords;
  }

  return pageInfo;
}

export function prepareRawQuery(rp, sortConfig) {
  if (!rp.rawQuery) {
    rp.rawQuery = {};
  }

  var beginCursorData = cursorToData(rp.args.after);
  if (beginCursorData) {
    var r = sortConfig.afterCursorQuery(rp.rawQuery, beginCursorData, rp);
    if (r !== undefined) {
      rp.rawQuery = r;
    }
  }

  var endCursorData = cursorToData(rp.args.before);
  if (endCursorData) {
    var _r = sortConfig.beforeCursorQuery(rp.rawQuery, endCursorData, rp);
    if (_r !== undefined) {
      rp.rawQuery = _r;
    }
  }
}

export function prepareLimitSkipFallback(rp, limit, skip) {
  var newLimit = limit;
  var newSkip = skip;

  var beforeSkip = 0;
  var afterSkip = 0;

  if (rp.args.before) {
    var tmp = cursorToData(rp.args.before);
    if (Number.isInteger(tmp)) {
      beforeSkip = parseInt(tmp, 10);
    }
  }
  if (rp.args.after) {
    var _tmp = cursorToData(rp.args.after);
    if (Number.isInteger(_tmp)) {
      afterSkip = parseInt(_tmp, 10) + 1;
    }
  }

  if (beforeSkip && afterSkip) {
    var rangeLimit = beforeSkip - afterSkip;
    if (rangeLimit < 0) {
      newLimit = 0;
      newSkip = skip + afterSkip;
    } else if (rangeLimit < limit) {
      newLimit = rangeLimit;
      newSkip = skip + beforeSkip - rangeLimit;
    } else {
      newSkip = skip + afterSkip;
    }
  } else if (beforeSkip) {
    newSkip = skip - beforeSkip;
    if (newSkip < 0) {
      newSkip = 0;
      newLimit = limit;
      // offset 0, so limit should not exceed offset in cursor, otherwise it returns again this record
      if (newLimit > beforeSkip) {
        newLimit = beforeSkip;
      }
    }
  } else if (afterSkip) {
    newSkip = afterSkip;
  }

  return [newLimit, newSkip];
}

export function emptyConnection() {
  return {
    count: 0,
    edges: [],
    pageInfo: {
      startCursor: '',
      endCursor: '',
      hasPreviousPage: false,
      hasNextPage: false
    }
  };
}

export function findSortConfig(configs, val) {
  // Object.keys(configs).forEach(k => {  // return does not works in forEach as I want
  for (var k in configs) {
    if (configs[k].value === val) {
      return configs[k];
    }
  }

  // Yep, I know that it's now good comparision, but fast solution for now
  // Sorry but complex sort value should has same key ordering
  //   cause {a: 1, b: 2} != {b: 2, a: 1}
  // BTW this code will be called only if arg.sort setuped by hands
  //   if graphql provides arg.sort, then first for-loop (above) done all work
  var valStringified = JSON.stringify(val);
  for (var _k in configs) {
    if (JSON.stringify(configs[_k].value) === valStringified) {
      return configs[_k];
    }
  }
}