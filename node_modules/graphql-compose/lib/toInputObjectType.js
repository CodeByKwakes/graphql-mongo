'use strict';

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = _assign2.default || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
/* eslint-disable no-use-before-define */

exports.removeWrongFields = removeWrongFields;
exports.toInputObjectType = toInputObjectType;
exports.convertInputObjectField = convertInputObjectField;

var _graphql = require('graphql');

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _typeComposer = require('./typeComposer');

var _typeComposer2 = _interopRequireDefault(_typeComposer);

var _inputTypeComposer = require('./inputTypeComposer');

var _inputTypeComposer2 = _interopRequireDefault(_inputTypeComposer);

var _generic = require('./type/generic');

var _generic2 = _interopRequireDefault(_generic);

var _misc = require('./utils/misc');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function removeWrongFields(fields) {
  var result = {};
  (0, _keys2.default)(fields).forEach(function (key) {
    var field = fields[key];
    if (!(0, _graphql.isAbstractType)(field.type) // skip interface fields
    && !field._gqcResolver // skip fields that obtained via Resolver
    ) {
        result[key] = field;
      }
  });
  return result;
}

function toInputObjectType(typeComposer) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeComposer.hasInputTypeComposer()) {
    return typeComposer.getInputTypeComposer();
  }

  var prefix = opts.prefix || '';
  var postfix = opts.postfix || 'Input';

  var name = '' + prefix + typeComposer.getTypeName() + postfix;

  var inputTypeComposer = new _inputTypeComposer2.default(new _graphql.GraphQLInputObjectType({
    name: name,
    fields: {}
  }));

  var outputFields = removeWrongFields(typeComposer.getFields());
  var inputFields = {};
  (0, _keys2.default)(outputFields).forEach(function (key) {
    var fieldOpts = _extends({}, opts, {
      fieldName: key,
      outputTypeName: typeComposer.getTypeName()
    });
    inputFields[key] = convertInputObjectField(outputFields[key], fieldOpts);
  });
  inputTypeComposer.addFields(inputFields);

  return inputTypeComposer;
}

function convertInputObjectField(field, opts) {
  var fieldType = field.type;

  var wrappers = [];
  while (fieldType instanceof _graphql.GraphQLList || fieldType instanceof _graphql.GraphQLNonNull) {
    wrappers.unshift(fieldType.constructor);
    fieldType = fieldType.ofType;
  }

  if (!(0, _graphql.isInputType)(fieldType)) {
    if (fieldType instanceof _graphql.GraphQLObjectType) {
      var typeOpts = {
        prefix: '' + (opts.prefix || '') + (0, _misc.upperFirst)(opts.outputTypeName || ''),
        postfix: opts.postfix || 'Input'
      };
      var typeComposer = new _typeComposer2.default(fieldType);
      fieldType = toInputObjectType(typeComposer, typeOpts).getType();
    } else {
      console.error('GQC: can not convert field \'' + (opts.outputTypeName || '') + '.' + (opts.fieldName || '') + '\' to InputType' // eslint-disable-line
      + '\nIt should be GraphQLObjectType, but got \n' + _util2.default.inspect(fieldType, { depth: 2, colors: true }));
      fieldType = _generic2.default;
    }
  }

  // $FlowFixMe
  var inputFieldType = wrappers.reduce(function (type, Wrapper) {
    return new Wrapper(type);
  }, fieldType);

  return { type: inputFieldType, description: field.description };
}