'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _defineProperty2 = require('babel-runtime/core-js/object/define-property');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = _assign2.default || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; (0, _defineProperty3.default)(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
/* eslint-disable no-use-before-define */

var _objectPath = require('object-path');

var _objectPath2 = _interopRequireDefault(_objectPath);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _graphql = require('graphql');

var _typeMapper = require('./typeMapper');

var _typeMapper2 = _interopRequireDefault(_typeMapper);

var _typeComposer = require('./typeComposer');

var _typeComposer2 = _interopRequireDefault(_typeComposer);

var _deepmerge = require('./utils/deepmerge');

var _deepmerge2 = _interopRequireDefault(_deepmerge);

var _misc = require('./utils/misc');

var _is = require('./utils/is');

var _projection = require('./projection');

var _inputTypeComposer = require('./inputTypeComposer');

var _inputTypeComposer2 = _interopRequireDefault(_inputTypeComposer);

var _typeByPath = require('./typeByPath');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { (0, _defineProperty3.default)(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Resolver = function () {
  function Resolver() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Resolver);

    if (!opts.name) {
      throw new Error('For Resolver constructor the `opts.name` is required option.');
    }
    this.name = opts.name;
    this.parent = opts.parent || null;
    this.kind = opts.kind || null;
    this.description = opts.description || '';

    if (opts.outputType) {
      this.setOutputType(opts.outputType);
    }

    if (opts.args) {
      this.args = _typeMapper2.default.convertArgConfigMap(opts.args, this.name, 'Resolver');
    } else {
      this.args = {};
    }

    if (opts.resolve) {
      this.resolve = opts.resolve;
    }
  }

  _createClass(Resolver, [{
    key: 'hasArg',
    value: function hasArg(argName) {
      return !!this.args[argName];
    }
  }, {
    key: 'getArg',
    value: function getArg(argName) {
      if (this.hasArg(argName)) {
        return this.args[argName];
      }
      return undefined;
    }
  }, {
    key: 'getArgType',
    value: function getArgType(argName) {
      var arg = this.getArg(argName);
      if (arg) {
        return arg.type;
      }
      return undefined;
    }
  }, {
    key: 'getArgs',
    value: function getArgs() {
      return this.args;
    }
  }, {
    key: 'setArgs',
    value: function setArgs(args) {
      this.args = _typeMapper2.default.convertArgConfigMap(args, this.name, 'Resolver');
    }
  }, {
    key: 'setArg',
    value: function setArg(argName, argConfig) {
      this.args[argName] = _typeMapper2.default.convertArgConfig(argConfig, argName, this.name, 'Resolver');
    }
  }, {
    key: 'addArgs',
    value: function addArgs(newArgs) {
      this.setArgs((0, _assign2.default)({}, this.getArgs(), newArgs));
    }
  }, {
    key: 'removeArg',
    value: function removeArg(argName) {
      delete this.args[argName];
    }
  }, {
    key: 'isRequired',
    value: function isRequired(argName) {
      return this.getArgType(argName) instanceof _graphql.GraphQLNonNull;
    }
  }, {
    key: 'makeRequired',
    value: function makeRequired(argNameOrArray) {
      var argNames = Array.isArray(argNameOrArray) ? argNameOrArray : [argNameOrArray];
      var args = this.getArgs();
      argNames.forEach(function (argName) {
        if (args[argName]) {
          if (!(args[argName].type instanceof _graphql.GraphQLNonNull)) {
            args[argName].type = new _graphql.GraphQLNonNull(args[argName].type);
          }
        }
      });
      this.setArgs(args);
    }
  }, {
    key: 'makeOptional',
    value: function makeOptional(argNameOrArray) {
      var argNames = Array.isArray(argNameOrArray) ? argNameOrArray : [argNameOrArray];
      var args = this.getArgs();
      argNames.forEach(function (argName) {
        if (argNames.includes(argName)) {
          if (args[argName].type instanceof _graphql.GraphQLNonNull) {
            args[argName].type = args[argName].type.ofType;
          }
        }
      });
      this.setArgs(args);
    }

    /*
    * This method should be overriden via constructor
    */

  }, {
    key: 'resolve',
    value: function resolve(resolveParams) {
      // eslint-disable-line
      return _promise2.default.resolve();
    }
  }, {
    key: 'getResolve',
    value: function getResolve() {
      return this.resolve;
    }
  }, {
    key: 'setResolve',
    value: function setResolve(resolve) {
      this.resolve = resolve;
    }
  }, {
    key: 'getOutputType',
    value: function getOutputType() {
      return this.outputType;
    }
  }, {
    key: 'setOutputType',
    value: function setOutputType(gqType) {
      var type = void 0;

      if (gqType instanceof _typeComposer2.default) {
        this.outputType = gqType.getType();
        return;
      }

      if (gqType instanceof Resolver) {
        this.outputType = gqType.getOutputType();
        return;
      }

      if (gqType instanceof _inputTypeComposer2.default) {
        throw new Error('You provide InputTypeComposer as OutputType for Resolver.outputType. It may by ScalarType or OutputObjectType.');
      }

      if ((0, _is.isString)(gqType)) {
        // $FlowFixMe
        if (gqType.indexOf('{') === -1) {
          // $FlowFixMe
          type = _typeMapper2.default.getWrapped(gqType);
        } else {
          // $FlowFixMe
          type = _typeMapper2.default.createType(gqType);
        }
      } else {
        type = gqType;
      }

      // $FlowFixMe
      if (!(0, _graphql.isOutputType)(type)) {
        throw new Error('You should provide correct OutputType for Resolver.outputType.');
      }
      // $FlowFixMe
      this.outputType = type;
    }
  }, {
    key: 'getFieldConfig',
    value: function getFieldConfig() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _resolve = this.getResolve();
      return {
        type: this.getOutputType(),
        args: this.getArgs(),
        description: this.description,
        resolve: function resolve(source, args, context, info) {
          var projection = (0, _projection.getProjectionFromAST)(info);
          if (opts.projection) {
            projection = (0, _deepmerge2.default)(projection, opts.projection);
          }
          return _resolve({ source: source, args: args, context: context, info: info, projection: projection });
        }
      };
    }
  }, {
    key: 'getKind',
    value: function getKind() {
      return this.kind;
    }
  }, {
    key: 'setKind',
    value: function setKind(kind) {
      if (kind !== 'query' && kind !== 'mutation' && kind !== 'subscription') {
        throw new Error('You provide incorrect value \'' + kind + '\' for Resolver.setKind method. ' + 'Valid values are: query | mutation | subscription');
      }
      this.kind = kind;
    }
  }, {
    key: 'getDescription',
    value: function getDescription() {
      return this.description;
    }
  }, {
    key: 'setDescription',
    value: function setDescription(description) {
      this.description = description;
    }
  }, {
    key: 'get',
    value: function get(path) {
      return (0, _typeByPath.typeByPath)(this, path);
    }
  }, {
    key: 'clone',
    value: function clone() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var oldOpts = {};
      for (var key in this) {
        // eslint-disable-line no-restricted-syntax
        if ({}.hasOwnProperty.call(this, key)) {
          // $FlowFixMe
          oldOpts[key] = this[key];
        }
      }
      oldOpts.args = (0, _assign2.default)({}, this.args);
      return new Resolver((0, _assign2.default)({}, oldOpts, opts));
    }
  }, {
    key: 'wrap',
    value: function wrap(cb) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var prevResolver = this;
      var newResolver = this.clone(_extends({
        name: 'wrap',
        parent: prevResolver
      }, opts));

      if ((0, _is.isFunction)(cb)) {
        // $FlowFixMe
        cb(newResolver, prevResolver);
      }

      return newResolver;
    }
  }, {
    key: 'wrapResolve',
    value: function wrapResolve(cb) {
      var wrapperName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'wrapResolve';

      return this.wrap(function (newResolver, prevResolver) {
        var newResolve = cb(prevResolver.getResolve());
        newResolver.setResolve(newResolve);
        return newResolver;
      }, { name: wrapperName });
    }
  }, {
    key: 'wrapArgs',
    value: function wrapArgs(cb) {
      var wrapperName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'wrapArgs';

      return this.wrap(function (newResolver, prevResolver) {
        // clone prevArgs, to avoid changing args in callback
        var prevArgs = (0, _assign2.default)({}, prevResolver.getArgs());
        var newArgs = cb(prevArgs);
        newResolver.setArgs(newArgs);
        return newResolver;
      }, { name: wrapperName });
    }
  }, {
    key: 'wrapOutputType',
    value: function wrapOutputType(cb) {
      var wrapperName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'wrapOutputType';

      return this.wrap(function (newResolver, prevResolver) {
        var prevOutputType = prevResolver.getOutputType();
        var newOutputType = cb(prevOutputType);
        newResolver.setOutputType(newOutputType);
        return newResolver;
      }, { name: wrapperName });
    }
  }, {
    key: 'addFilterArg',
    value: function addFilterArg(opts) {
      if (!opts.name) {
        throw new Error('For Resolver.addFilterArg the arg name `opts.name` is required.');
      }

      if (!opts.type) {
        throw new Error('For Resolver.addFilterArg the arg type `opts.type` is required.');
      }

      var resolver = this.wrap(null, { name: 'addFilterArg' });

      // get filterTC or create new one argument
      var filter = resolver.getArg('filter');
      var filterITC = void 0;
      if (filter && filter.type instanceof _graphql.GraphQLInputObjectType) {
        filterITC = new _inputTypeComposer2.default(filter.type);
      } else {
        if (!opts.filterTypeNameFallback || !(0, _is.isString)(opts.filterTypeNameFallback)) {
          throw new Error('For Resolver.addFilterArg needs to provide `opts.filterTypeNameFallback: string`. ' + 'This string will be used as unique name for `filter` type of input argument. ' + 'Eg. FilterXXXXXInput');
        }
        filterITC = _inputTypeComposer2.default.create(opts.filterTypeNameFallback);
      }

      var defaultValue = void 0;
      if (filter && filter.defaultValue) {
        defaultValue = filter.defaultValue;
      }
      if (opts.defaultValue) {
        if (!defaultValue) {
          defaultValue = {};
        }
        // $FlowFixMe
        defaultValue[opts.name] = opts.defaultValue;
      }

      resolver.setArg('filter', {
        type: filterITC.getType(),
        description: filter && filter.description || undefined,
        defaultValue: defaultValue
      });

      filterITC.setField(opts.name, _extends({}, (0, _misc.only)(opts, ['name', 'type', 'defaultValue', 'description'])));

      var resolveNext = resolver.getResolve();
      if ((0, _is.isFunction)(opts.query)) {
        resolver.setResolve(function (resolveParams) {
          var value = _objectPath2.default.get(resolveParams, ['args', 'filter', opts.name]);
          if (value) {
            if (!resolveParams.rawQuery) {
              resolveParams.rawQuery = {}; // eslint-disable-line
            }
            opts.query(resolveParams.rawQuery, value, resolveParams);
          }
          return resolveNext(resolveParams);
        });
      }

      return resolver;
    }
  }, {
    key: 'addSortArg',
    value: function addSortArg(opts) {
      if (!opts.name) {
        throw new Error('For Resolver.addSortArg the `opts.name` is required.');
      }

      if (!opts.value) {
        throw new Error('For Resolver.addSortArg the `opts.value` is required.');
      }

      var resolver = this.wrap(null, { name: 'addSortArg' });

      // get sortEnumType or create new one
      var sort = resolver.getArg('sort');
      var sortEnumType = void 0;
      if (sort) {
        if (sort.type instanceof _graphql.GraphQLEnumType) {
          sortEnumType = sort.type;
        } else {
          throw new Error('Resolver should have `sort` arg with type GraphQLEnumType. ' + ('But got: ' + _util2.default.inspect(sort.type, { depth: 2 }) + ' '));
        }
      } else {
        if (!opts.sortTypeNameFallback || !(0, _is.isString)(opts.sortTypeNameFallback)) {
          throw new Error('For Resolver.addSortArg needs to provide `opts.sortTypeNameFallback: string`. ' + 'This string will be used as unique name for `sort` type of input argument. ' + 'Eg. SortXXXXXEnum');
        }
        sortEnumType = new _graphql.GraphQLEnumType({
          name: opts.sortTypeNameFallback,
          values: _defineProperty({}, opts.name, {})
        });
        resolver.setArg('sort', { type: sortEnumType });
      }

      // extend sortEnumType with new sorting value
      var existedIdx = sortEnumType._values.findIndex(function (o) {
        return o.name === opts.name;
      });
      if (existedIdx >= 0) {
        sortEnumType._values.splice(existedIdx, 1);
      }
      delete sortEnumType._nameLookup;
      delete sortEnumType._valueLookup;
      sortEnumType._values.push({
        name: opts.name,
        description: opts.description,
        isDeprecated: Boolean(opts.deprecationReason),
        deprecationReason: opts.deprecationReason,
        value: (0, _is.isFunction)(opts.value) ? opts.name : opts.value
      });

      // If sort value is evaluable (function), then wrap resolve method
      var resolveNext = resolver.getResolve();
      if ((0, _is.isFunction)(opts.value)) {
        resolver.setResolve(function (resolveParams) {
          var value = _objectPath2.default.get(resolveParams, ['args', 'sort']);
          if (value === opts.name) {
            // $FlowFixMe
            var newSortValue = opts.value(resolveParams);
            resolveParams.args.sort = newSortValue; // eslint-disable-line
          }
          return resolveNext(resolveParams);
        });
      }

      return resolver;
    }
  }, {
    key: 'getNestedName',
    value: function getNestedName() {
      if (this.parent) {
        return this.name + '(' + this.parent.getNestedName() + ')';
      }
      return this.name;
    }
  }, {
    key: 'toString',
    value: function toString() {
      function extendedInfo(resolver) {
        var spaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        return ['Resolver(', '  name: ' + resolver.name + ',', '  outputType: ' + _util2.default.inspect(resolver.outputType, { depth: 2 }) + ',', '  args: ' + _util2.default.inspect(resolver.args, { depth: 3 }).replace('\n', '\n  ' + spaces) + ',', '  resolve: ' + (resolver.resolve ? resolver.resolve.toString().replace('\n', '\n  ' + spaces) : 'undefined') + ',', '  parent: ' + (resolver.parent ? extendedInfo(resolver.parent, '  ' + spaces) : ''), ')'].filter(function (s) {
          return !!s;
        }).join('\n  ' + spaces);
      }

      return extendedInfo(this);
    }
  }]);

  return Resolver;
}();

exports.default = Resolver;