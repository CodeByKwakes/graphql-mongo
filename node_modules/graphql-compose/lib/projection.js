'use strict';

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _iterator = require('babel-runtime/core-js/symbol/iterator');

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

var _extends = _assign2.default || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.getProjectionFromAST = getProjectionFromAST;
exports.getFlatProjectionFromAST = getFlatProjectionFromAST;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return (0, _from2.default)(arr); } }

/* eslint-disable no-param-reassign */

function getProjectionFromAST(context, fieldNodes) /* :ProjectionType */{
  if (!context) {
    return null;
  }

  var asts = fieldNodes || context.fieldNodes || context.fieldASTs;
  if (!Array.isArray(asts)) {
    asts = [asts];
  }

  // get all selectionSets
  var selections = asts.reduce(function (result, source) {
    if (source.selectionSet) {
      result.push.apply(result, _toConsumableArray(source.selectionSet.selections));
    }

    return result;
  }, []);

  var projection = selections.reduce(function (list, ast) {
    var name = ast.name;
    var kind = ast.kind;


    switch (kind) {
      case 'Field':
        list = list || {};
        list[name.value] = getProjectionFromAST(context, ast) || true;
        return list;
      case 'InlineFragment':
        return _extends({}, list, getProjectionFromAST(context, ast));
      case 'FragmentSpread':
        return _extends({}, list, getProjectionFromAST(context, context.fragments[name.value]));
      default:
        throw new Error('Unsuported query selection');
    }
  }, null);

  // this type params are setup via TypeComposer.addProjectionMapper()
  // Sometimes, when you create relations you need query additional fields, that not in query.
  // Eg. for obtaining `friendList` you also should add `friendIds` to projection.
  if (projection && context.returnType) {
    (function () {
      var returnType = context.returnType;
      while (returnType.ofType) {
        returnType = returnType.ofType;
      }
      if (_typeof(returnType._gqcProjectionMapper) === 'object') {
        (0, _keys2.default)(returnType._gqcProjectionMapper).forEach(function (key) {
          if (projection[key]) {
            (0, _assign2.default)(projection, returnType._gqcProjectionMapper[key]);
          }
        });
      }
    })();
  }
  return projection;
}

function getFlatProjectionFromAST(context, fieldNodes) {
  var projection = getProjectionFromAST(context, fieldNodes);
  var flatProjection = {};
  (0, _keys2.default)(projection).forEach(function (key) {
    flatProjection[key] = !!projection[key];
  });
  return flatProjection;
}