'use strict';

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _defineProperty2 = require('babel-runtime/core-js/object/define-property');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = _assign2.default || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; (0, _defineProperty3.default)(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _graphql = require('graphql');

var _misc = require('./utils/misc');

var _debug = require('./utils/debug');

var _is = require('./utils/is');

var _typeMapper = require('./typeMapper');

var _typeMapper2 = _interopRequireDefault(_typeMapper);

var _typeByPath = require('./typeByPath');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { (0, _defineProperty3.default)(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var InputTypeComposer = function () {
  _createClass(InputTypeComposer, null, [{
    key: 'create',
    value: function create(opts) {
      var ITC = void 0;

      if ((0, _is.isString)(opts)) {
        // $FlowFixMe
        var typeName = opts;
        var NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
        if (NAME_RX.test(typeName)) {
          ITC = new InputTypeComposer(new _graphql.GraphQLInputObjectType({
            name: typeName,
            fields: function fields() {
              return {};
            }
          }));
        } else {
          var type = _typeMapper2.default.createType(typeName);
          if (!(type instanceof _graphql.GraphQLInputObjectType)) {
            throw new Error('You should provide correct GraphQLInputObjectType type definition.');
          }
          ITC = new InputTypeComposer(type);
        }
      } else if (opts instanceof _graphql.GraphQLInputObjectType) {
        ITC = new InputTypeComposer(opts);
      } else if ((0, _is.isObject)(opts)) {
        // $FlowFixMe
        var _type = new _graphql.GraphQLInputObjectType(_extends({}, opts, {
          fields: function fields() {
            return {};
          }
        }));
        ITC = new InputTypeComposer(_type);

        // $FlowFixMe
        if ((0, _is.isObject)(opts.fields)) {
          ITC.addFields(opts.fields);
        }
      } else {
        throw new Error('You should provide InputObjectConfig or string with type name to InputTypeComposer.create(opts)');
      }

      return ITC;
    }
  }]);

  function InputTypeComposer(gqType) {
    _classCallCheck(this, InputTypeComposer);

    if (!(gqType instanceof _graphql.GraphQLInputObjectType)) {
      throw new Error('InputTypeComposer accept only GraphQLInputObjectType in constructor');
    }
    this.gqType = gqType;
  }

  /**
   * Get fields from a GraphQL type
   * WARNING: this method read an internal GraphQL instance variable.
   */


  _createClass(InputTypeComposer, [{
    key: 'getFields',
    value: function getFields() {
      var fields = this.gqType._typeConfig.fields;

      var fieldMap = (0, _misc.resolveMaybeThunk)(fields);

      if ((0, _is.isObject)(fieldMap)) {
        return (0, _assign2.default)({}, fieldMap);
      }
      return {};
    }
  }, {
    key: 'getFieldNames',
    value: function getFieldNames() {
      return (0, _keys2.default)(this.getFields());
    }
  }, {
    key: 'hasField',
    value: function hasField(fieldName) {
      var fields = this.getFields();
      return !!fields[fieldName];
    }

    /**
     * Completely replace all fields in GraphQL type
     * WARNING: this method rewrite an internal GraphQL instance variable.
     */

  }, {
    key: 'setFields',
    value: function setFields(fields) {
      var prepearedFields = _typeMapper2.default.convertInputFieldConfigMap(fields, this.getTypeName());

      this.gqType._typeConfig.fields = function () {
        return prepearedFields;
      };
      delete this.gqType._fields; // if schema was builded, delete defineFieldMap
    }
  }, {
    key: 'setField',
    value: function setField(fieldName, fieldConfig) {
      this.addFields(_defineProperty({}, fieldName, fieldConfig));
    }

    /**
    * @deprecated 2.0.0
    */

  }, {
    key: 'addField',
    value: function addField(fieldName, fieldConfig) {
      (0, _debug.deprecate)('Use InputTypeComposer.setField() or plural addFields({}) instead.');
      this.addFields(_defineProperty({}, fieldName, fieldConfig));
    }

    /**
     * Add new fields or replace existed in a GraphQL type
     */

  }, {
    key: 'addFields',
    value: function addFields(newFields) {
      this.setFields((0, _assign2.default)({}, this.getFields(), newFields));
    }

    /**
     * Get fieldConfig by name
     */

  }, {
    key: 'getField',
    value: function getField(fieldName) {
      var fields = this.getFields();

      if (fields[fieldName]) {
        return fields[fieldName];
      }

      return undefined;
    }
  }, {
    key: 'removeField',
    value: function removeField(fieldNameOrArray) {
      var fieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
      var fields = this.getFields();
      fieldNames.forEach(function (fieldName) {
        return delete fields[fieldName];
      });
      this.setFields(fields);
    }
  }, {
    key: 'clone',
    value: function clone(newTypeName) {
      if (!newTypeName) {
        throw new Error('You should provide new type name for clone() method');
      }

      var fields = this.getFields();
      var newFields = {};
      (0, _keys2.default)(fields).forEach(function (fieldName) {
        newFields[fieldName] = (0, _assign2.default)({}, fields[fieldName]);
      });

      return new InputTypeComposer(new _graphql.GraphQLInputObjectType({
        name: newTypeName,
        fields: newFields
      }));
    }

    /**
     * Get fieldType by name
     */

  }, {
    key: 'getFieldType',
    value: function getFieldType(fieldName) {
      var field = this.getField(fieldName);
      if (field) {
        return field.type;
      }

      return undefined;
    }
  }, {
    key: 'getType',
    value: function getType() {
      return this.gqType;
    }
  }, {
    key: 'getTypeName',
    value: function getTypeName() {
      return this.gqType.name;
    }
  }, {
    key: 'setTypeName',
    value: function setTypeName(name) {
      this.gqType.name = name;
    }
  }, {
    key: 'getDescription',
    value: function getDescription() {
      return this.gqType.description || '';
    }
  }, {
    key: 'setDescription',
    value: function setDescription(description) {
      this.gqType.description = description;
    }
  }, {
    key: 'isRequired',
    value: function isRequired(fieldName) {
      return this.getFieldType(fieldName) instanceof _graphql.GraphQLNonNull;
    }

    /**
    * @deprecated 2.0.0
    */

  }, {
    key: 'isFieldRequired',
    value: function isFieldRequired(fieldName) {
      (0, _debug.deprecate)('Use InputTypeComposer.isRequired() instead.');
      return this.isRequired(fieldName);
    }
  }, {
    key: 'makeRequired',
    value: function makeRequired(fieldNameOrArray) {
      var fieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
      var fields = this.getFields();
      fieldNames.forEach(function (fieldName) {
        if (fields[fieldName]) {
          if (!(fields[fieldName].type instanceof _graphql.GraphQLNonNull)) {
            fields[fieldName].type = new _graphql.GraphQLNonNull(fields[fieldName].type);
          }
        }
      });
      this.setFields(fields);
    }

    /**
    * @deprecated 2.0.0
    */

  }, {
    key: 'makeFieldsRequired',
    value: function makeFieldsRequired(fieldNameOrArray) {
      (0, _debug.deprecate)('Use InputTypeComposer.makeRequired() instead.');
      this.makeRequired(fieldNameOrArray);
    }
  }, {
    key: 'makeOptional',
    value: function makeOptional(fieldNameOrArray) {
      var fieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
      var fields = this.getFields();
      fieldNames.forEach(function (fieldName) {
        if (fieldNames.includes(fieldName)) {
          if (fields[fieldName].type instanceof _graphql.GraphQLNonNull) {
            fields[fieldName].type = fields[fieldName].type.ofType;
          }
        }
      });
      this.setFields(fields);
    }

    /**
    * @deprecated 2.0.0
    */

  }, {
    key: 'makeFieldsOptional',
    value: function makeFieldsOptional(fieldNameOrArray) {
      (0, _debug.deprecate)('Use InputTypeComposer.makeOptional() instead.');
      this.makeOptional(fieldNameOrArray);
    }

    /**
    * @deprecated 2.0.0
    */

  }, {
    key: 'getByPath',
    value: function getByPath(path) {
      (0, _debug.deprecate)('Use InputTypeComposer.get() instead.');
      return this.get(path);
    }
  }, {
    key: 'get',
    value: function get(path) {
      return (0, _typeByPath.typeByPath)(this, path);
    }
  }]);

  return InputTypeComposer;
}();

exports.default = InputTypeComposer;