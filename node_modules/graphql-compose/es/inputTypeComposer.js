var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { GraphQLInputObjectType, GraphQLNonNull } from 'graphql';
import { resolveMaybeThunk } from './utils/misc';
import { deprecate } from './utils/debug';
import { isObject, isString } from './utils/is';
import TypeMapper from './typeMapper';
import { typeByPath } from './typeByPath';

var InputTypeComposer = function () {
  _createClass(InputTypeComposer, null, [{
    key: 'create',
    value: function create(opts) {
      var ITC = void 0;

      if (isString(opts)) {
        // $FlowFixMe
        var typeName = opts;
        var NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
        if (NAME_RX.test(typeName)) {
          ITC = new InputTypeComposer(new GraphQLInputObjectType({
            name: typeName,
            fields: function fields() {
              return {};
            }
          }));
        } else {
          var type = TypeMapper.createType(typeName);
          if (!(type instanceof GraphQLInputObjectType)) {
            throw new Error('You should provide correct GraphQLInputObjectType type definition.');
          }
          ITC = new InputTypeComposer(type);
        }
      } else if (opts instanceof GraphQLInputObjectType) {
        ITC = new InputTypeComposer(opts);
      } else if (isObject(opts)) {
        // $FlowFixMe
        var _type = new GraphQLInputObjectType(_extends({}, opts, {
          fields: function fields() {
            return {};
          }
        }));
        ITC = new InputTypeComposer(_type);

        // $FlowFixMe
        if (isObject(opts.fields)) {
          ITC.addFields(opts.fields);
        }
      } else {
        throw new Error('You should provide InputObjectConfig or string with type name to InputTypeComposer.create(opts)');
      }

      return ITC;
    }
  }]);

  function InputTypeComposer(gqType) {
    _classCallCheck(this, InputTypeComposer);

    if (!(gqType instanceof GraphQLInputObjectType)) {
      throw new Error('InputTypeComposer accept only GraphQLInputObjectType in constructor');
    }
    this.gqType = gqType;
  }

  /**
   * Get fields from a GraphQL type
   * WARNING: this method read an internal GraphQL instance variable.
   */


  _createClass(InputTypeComposer, [{
    key: 'getFields',
    value: function getFields() {
      var fields = this.gqType._typeConfig.fields;

      var fieldMap = resolveMaybeThunk(fields);

      if (isObject(fieldMap)) {
        return Object.assign({}, fieldMap);
      }
      return {};
    }
  }, {
    key: 'getFieldNames',
    value: function getFieldNames() {
      return Object.keys(this.getFields());
    }
  }, {
    key: 'hasField',
    value: function hasField(fieldName) {
      var fields = this.getFields();
      return !!fields[fieldName];
    }

    /**
     * Completely replace all fields in GraphQL type
     * WARNING: this method rewrite an internal GraphQL instance variable.
     */

  }, {
    key: 'setFields',
    value: function setFields(fields) {
      var prepearedFields = TypeMapper.convertInputFieldConfigMap(fields, this.getTypeName());

      this.gqType._typeConfig.fields = function () {
        return prepearedFields;
      };
      delete this.gqType._fields; // if schema was builded, delete defineFieldMap
    }
  }, {
    key: 'setField',
    value: function setField(fieldName, fieldConfig) {
      this.addFields(_defineProperty({}, fieldName, fieldConfig));
    }

    /**
    * @deprecated 2.0.0
    */

  }, {
    key: 'addField',
    value: function addField(fieldName, fieldConfig) {
      deprecate('Use InputTypeComposer.setField() or plural addFields({}) instead.');
      this.addFields(_defineProperty({}, fieldName, fieldConfig));
    }

    /**
     * Add new fields or replace existed in a GraphQL type
     */

  }, {
    key: 'addFields',
    value: function addFields(newFields) {
      this.setFields(Object.assign({}, this.getFields(), newFields));
    }

    /**
     * Get fieldConfig by name
     */

  }, {
    key: 'getField',
    value: function getField(fieldName) {
      var fields = this.getFields();

      if (fields[fieldName]) {
        return fields[fieldName];
      }

      return undefined;
    }
  }, {
    key: 'removeField',
    value: function removeField(fieldNameOrArray) {
      var fieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
      var fields = this.getFields();
      fieldNames.forEach(function (fieldName) {
        return delete fields[fieldName];
      });
      this.setFields(fields);
    }
  }, {
    key: 'clone',
    value: function clone(newTypeName) {
      if (!newTypeName) {
        throw new Error('You should provide new type name for clone() method');
      }

      var fields = this.getFields();
      var newFields = {};
      Object.keys(fields).forEach(function (fieldName) {
        newFields[fieldName] = Object.assign({}, fields[fieldName]);
      });

      return new InputTypeComposer(new GraphQLInputObjectType({
        name: newTypeName,
        fields: newFields
      }));
    }

    /**
     * Get fieldType by name
     */

  }, {
    key: 'getFieldType',
    value: function getFieldType(fieldName) {
      var field = this.getField(fieldName);
      if (field) {
        return field.type;
      }

      return undefined;
    }
  }, {
    key: 'getType',
    value: function getType() {
      return this.gqType;
    }
  }, {
    key: 'getTypeName',
    value: function getTypeName() {
      return this.gqType.name;
    }
  }, {
    key: 'setTypeName',
    value: function setTypeName(name) {
      this.gqType.name = name;
    }
  }, {
    key: 'getDescription',
    value: function getDescription() {
      return this.gqType.description || '';
    }
  }, {
    key: 'setDescription',
    value: function setDescription(description) {
      this.gqType.description = description;
    }
  }, {
    key: 'isRequired',
    value: function isRequired(fieldName) {
      return this.getFieldType(fieldName) instanceof GraphQLNonNull;
    }

    /**
    * @deprecated 2.0.0
    */

  }, {
    key: 'isFieldRequired',
    value: function isFieldRequired(fieldName) {
      deprecate('Use InputTypeComposer.isRequired() instead.');
      return this.isRequired(fieldName);
    }
  }, {
    key: 'makeRequired',
    value: function makeRequired(fieldNameOrArray) {
      var fieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
      var fields = this.getFields();
      fieldNames.forEach(function (fieldName) {
        if (fields[fieldName]) {
          if (!(fields[fieldName].type instanceof GraphQLNonNull)) {
            fields[fieldName].type = new GraphQLNonNull(fields[fieldName].type);
          }
        }
      });
      this.setFields(fields);
    }

    /**
    * @deprecated 2.0.0
    */

  }, {
    key: 'makeFieldsRequired',
    value: function makeFieldsRequired(fieldNameOrArray) {
      deprecate('Use InputTypeComposer.makeRequired() instead.');
      this.makeRequired(fieldNameOrArray);
    }
  }, {
    key: 'makeOptional',
    value: function makeOptional(fieldNameOrArray) {
      var fieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
      var fields = this.getFields();
      fieldNames.forEach(function (fieldName) {
        if (fieldNames.includes(fieldName)) {
          if (fields[fieldName].type instanceof GraphQLNonNull) {
            fields[fieldName].type = fields[fieldName].type.ofType;
          }
        }
      });
      this.setFields(fields);
    }

    /**
    * @deprecated 2.0.0
    */

  }, {
    key: 'makeFieldsOptional',
    value: function makeFieldsOptional(fieldNameOrArray) {
      deprecate('Use InputTypeComposer.makeOptional() instead.');
      this.makeOptional(fieldNameOrArray);
    }

    /**
    * @deprecated 2.0.0
    */

  }, {
    key: 'getByPath',
    value: function getByPath(path) {
      deprecate('Use InputTypeComposer.get() instead.');
      return this.get(path);
    }
  }, {
    key: 'get',
    value: function get(path) {
      return typeByPath(this, path);
    }
  }]);

  return InputTypeComposer;
}();

export default InputTypeComposer;