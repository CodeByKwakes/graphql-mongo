var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* eslint-disable no-param-reassign */

export function getProjectionFromAST(context, fieldNodes) /* :ProjectionType */{
  if (!context) {
    return null;
  }

  var asts = fieldNodes || context.fieldNodes || context.fieldASTs;
  if (!Array.isArray(asts)) {
    asts = [asts];
  }

  // get all selectionSets
  var selections = asts.reduce(function (result, source) {
    if (source.selectionSet) {
      result.push.apply(result, _toConsumableArray(source.selectionSet.selections));
    }

    return result;
  }, []);

  var projection = selections.reduce(function (list, ast) {
    var name = ast.name;
    var kind = ast.kind;


    switch (kind) {
      case 'Field':
        list = list || {};
        list[name.value] = getProjectionFromAST(context, ast) || true;
        return list;
      case 'InlineFragment':
        return _extends({}, list, getProjectionFromAST(context, ast));
      case 'FragmentSpread':
        return _extends({}, list, getProjectionFromAST(context, context.fragments[name.value]));
      default:
        throw new Error('Unsuported query selection');
    }
  }, null);

  // this type params are setup via TypeComposer.addProjectionMapper()
  // Sometimes, when you create relations you need query additional fields, that not in query.
  // Eg. for obtaining `friendList` you also should add `friendIds` to projection.
  if (projection && context.returnType) {
    (function () {
      var returnType = context.returnType;
      while (returnType.ofType) {
        returnType = returnType.ofType;
      }
      if (_typeof(returnType._gqcProjectionMapper) === 'object') {
        Object.keys(returnType._gqcProjectionMapper).forEach(function (key) {
          if (projection[key]) {
            Object.assign(projection, returnType._gqcProjectionMapper[key]);
          }
        });
      }
    })();
  }
  return projection;
}

export function getFlatProjectionFromAST(context, fieldNodes) {
  var projection = getProjectionFromAST(context, fieldNodes);
  var flatProjection = {};
  Object.keys(projection).forEach(function (key) {
    flatProjection[key] = !!projection[key];
  });
  return flatProjection;
}