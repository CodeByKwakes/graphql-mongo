var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/* eslint-disable no-use-before-define */

import { GraphQLInputObjectType, GraphQLObjectType, isInputType, isAbstractType, GraphQLList, GraphQLNonNull } from 'graphql';
import util from 'util';
import TypeComposer from './typeComposer';
import InputTypeComposer from './inputTypeComposer';
import GenericType from './type/generic';
import { upperFirst } from './utils/misc';


export function removeWrongFields(fields) {
  var result = {};
  Object.keys(fields).forEach(function (key) {
    var field = fields[key];
    if (!isAbstractType(field.type) // skip interface fields
    && !field._gqcResolver // skip fields that obtained via Resolver
    ) {
        result[key] = field;
      }
  });
  return result;
}

export function toInputObjectType(typeComposer) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeComposer.hasInputTypeComposer()) {
    return typeComposer.getInputTypeComposer();
  }

  var prefix = opts.prefix || '';
  var postfix = opts.postfix || 'Input';

  var name = '' + prefix + typeComposer.getTypeName() + postfix;

  var inputTypeComposer = new InputTypeComposer(new GraphQLInputObjectType({
    name: name,
    fields: {}
  }));

  var outputFields = removeWrongFields(typeComposer.getFields());
  var inputFields = {};
  Object.keys(outputFields).forEach(function (key) {
    var fieldOpts = _extends({}, opts, {
      fieldName: key,
      outputTypeName: typeComposer.getTypeName()
    });
    inputFields[key] = convertInputObjectField(outputFields[key], fieldOpts);
  });
  inputTypeComposer.addFields(inputFields);

  return inputTypeComposer;
}

export function convertInputObjectField(field, opts) {
  var fieldType = field.type;

  var wrappers = [];
  while (fieldType instanceof GraphQLList || fieldType instanceof GraphQLNonNull) {
    wrappers.unshift(fieldType.constructor);
    fieldType = fieldType.ofType;
  }

  if (!isInputType(fieldType)) {
    if (fieldType instanceof GraphQLObjectType) {
      var typeOpts = {
        prefix: '' + (opts.prefix || '') + upperFirst(opts.outputTypeName || ''),
        postfix: opts.postfix || 'Input'
      };
      var typeComposer = new TypeComposer(fieldType);
      fieldType = toInputObjectType(typeComposer, typeOpts).getType();
    } else {
      console.error('GQC: can not convert field \'' + (opts.outputTypeName || '') + '.' + (opts.fieldName || '') + '\' to InputType' // eslint-disable-line
      + '\nIt should be GraphQLObjectType, but got \n' + util.inspect(fieldType, { depth: 2, colors: true }));
      fieldType = GenericType;
    }
  }

  // $FlowFixMe
  var inputFieldType = wrappers.reduce(function (type, Wrapper) {
    return new Wrapper(type);
  }, fieldType);

  return { type: inputFieldType, description: field.description };
}