var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* eslint-disable no-use-before-define */

import { GraphQLNonNull, GraphQLInputObjectType, GraphQLList, getNamedType } from 'graphql';
import { TypeComposer, InputTypeComposer } from 'graphql-compose';
import { getIndexesFromModel } from '../../utils/getIndexesFromModel';
import { isObject } from '../../utils/is';
import { toDottedObject, upperFirst } from '../../utils';
import typeStorage from '../../typeStorage';


export var OPERATORS_FIELDNAME = '_operators';

export var filterHelperArgs = function filterHelperArgs(typeComposer, model, opts) {
  if (!(typeComposer instanceof TypeComposer)) {
    throw new Error('First arg for filterHelperArgs() should be instance of TypeComposer.');
  }

  if (!model || !model.modelName || !model.schema) {
    throw new Error('Second arg for filterHelperArgs() should be instance of MongooseModel.');
  }

  if (!opts || !opts.filterTypeName) {
    throw new Error('You should provide non-empty `filterTypeName` in options.');
  }

  var removeFields = [];
  if (opts.removeFields) {
    if (Array.isArray(opts.removeFields)) {
      removeFields.push.apply(removeFields, _toConsumableArray(opts.removeFields));
    } else {
      removeFields.push(opts.removeFields);
    }
  }

  if (opts.onlyIndexed) {
    (function () {
      var indexedFieldNames = getIndexedFieldNames(model);
      Object.keys(typeComposer.getFields()).forEach(function (fieldName) {
        if (indexedFieldNames.indexOf(fieldName) === -1) {
          removeFields.push(fieldName);
        }
      });
    })();
  }

  var filterTypeName = opts.filterTypeName;
  var inputComposer = typeComposer.getInputTypeComposer().clone(filterTypeName);
  inputComposer.removeField(removeFields);

  if (opts.requiredFields) {
    inputComposer.makeRequired(opts.requiredFields);
  }

  if (!{}.hasOwnProperty.call(opts, 'operators') || opts.operators !== false) {
    addFieldsWithOperator(
    // $FlowFixMe
    'Operators' + opts.filterTypeName, inputComposer, model, opts.operators || {});
  }

  if (inputComposer.getFieldNames().length === 0) {
    return {};
  }

  return {
    filter: {
      name: 'filter',
      type: opts.isRequired ? new GraphQLNonNull(inputComposer.getType()) : inputComposer.getType(),
      description: opts.onlyIndexed ? 'Filter only by indexed fields' : 'Filter by fields'
    }
  };
};

export function filterHelper(resolveParams) {
  // $FlowFixMe
  var filter = resolveParams.args && resolveParams.args.filter;
  if (filter && (typeof filter === 'undefined' ? 'undefined' : _typeof(filter)) === 'object' && Object.keys(filter).length > 0) {
    (function () {
      var modelFields = resolveParams.query.schema.paths;
      var clearedFilter = {};
      Object.keys(filter).forEach(function (key) {
        if (modelFields[key]) {
          clearedFilter[key] = filter[key];
        }
      });
      if (Object.keys(clearedFilter).length > 0) {
        resolveParams.query = resolveParams.query.where(toDottedObject(clearedFilter)); // eslint-disable-line
      }

      if (filter[OPERATORS_FIELDNAME]) {
        (function () {
          var operatorFields = filter[OPERATORS_FIELDNAME];
          Object.keys(operatorFields).forEach(function (fieldName) {
            var fieldOperators = Object.assign({}, operatorFields[fieldName]);
            var criteria = {};
            Object.keys(fieldOperators).forEach(function (operatorName) {
              criteria['$' + operatorName] = fieldOperators[operatorName];
            });
            if (Object.keys(criteria).length > 0) {
              resolveParams.query = resolveParams.query.where(_defineProperty({}, fieldName, criteria));
            }
          });
        })();
      }
    })();
  }

  if (isObject(resolveParams.rawQuery)) {
    resolveParams.query = resolveParams.query.where( // eslint-disable-line
    // $FlowFixMe
    resolveParams.rawQuery);
  }
}

export function getIndexedFieldNames(model) {
  var indexes = getIndexesFromModel(model);

  var fieldNames = [];
  indexes.forEach(function (indexData) {
    var keys = Object.keys(indexData);
    var clearedName = keys[0].replace(/[^_a-zA-Z0-9]/i, '__');
    fieldNames.push(clearedName);
  });

  return fieldNames;
}

export function addFieldsWithOperator(typeName, inputComposer, model, operatorsOpts) {
  var operatorsComposer = new InputTypeComposer(typeStorage.getOrSet(typeName, new GraphQLInputObjectType({
    name: typeName,
    fields: {}
  })));

  var availableOperators = ['gt', 'gte', 'lt', 'lte', 'ne', 'in[]', 'nin[]'];

  // if `opts.resolvers.[resolverName].filter.operators` is empty and not disabled via `false`
  // then fill it up with indexed fields
  var indexedFields = getIndexedFieldNames(model);
  if (operatorsOpts !== false && Object.keys(operatorsOpts).length === 0) {
    indexedFields.forEach(function (fieldName) {
      operatorsOpts[fieldName] = availableOperators; // eslint-disable-line
    });
  }

  var existedFields = inputComposer.getFields();
  Object.keys(existedFields).forEach(function (fieldName) {
    if (operatorsOpts[fieldName] && operatorsOpts[fieldName] !== false) {
      (function () {
        var fields = {};
        var operators = void 0;
        if (operatorsOpts[fieldName] && Array.isArray(operatorsOpts[fieldName])) {
          operators = operatorsOpts[fieldName];
        } else {
          operators = availableOperators;
        }
        operators.forEach(function (operatorName) {
          // unwrap from GraphQLNonNull and GraphQLList, if present
          var namedType = getNamedType(existedFields[fieldName].type);
          if (namedType) {
            if (operatorName.slice(-2) === '[]') {
              // wrap with GraphQLList, if operator required this with `[]`
              var newName = operatorName.slice(0, -2);
              fields[newName] = _extends({}, existedFields[fieldName], {
                type: new GraphQLList(namedType)
              });
            } else {
              fields[operatorName] = _extends({}, existedFields[fieldName], {
                type: namedType
              });
            }
          }
        });
        if (Object.keys(fields).length > 0) {
          var operatorTypeName = '' + upperFirst(fieldName) + typeName;
          operatorsComposer.setField(fieldName, {
            type: typeStorage.getOrSet(operatorTypeName, new GraphQLInputObjectType({
              name: operatorTypeName,
              fields: fields
            })),
            description: 'Filter value by operator(s)'
          });
        }
      })();
    }
  });

  if (Object.keys(operatorsComposer.getFields()).length > 0) {
    inputComposer.setField(OPERATORS_FIELDNAME, {
      type: operatorsComposer.getType(),
      description: 'List of fields that can be filtered via operators'
    });
  }

  return operatorsComposer;
}